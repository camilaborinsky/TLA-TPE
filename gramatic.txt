
DECLARATION -> let id : TYPE ;
ASIGNATION -> id = ASSIGNATION_VALUES ;
ASSIGNATION_VALUES -> id | FUNCTION_CALL | CONST
FUNCTION_CALL -> id(PARAMS_VALUES);
PARAMS_VALUES -> lambda | PARAMS
PARAMS -> id | PARAMS , id
FUNCTION -> function id : TYPE ( PARAMS_DECLARATION ){ CODE } 
PARAMS_DECLARATION -> lambda | PARAMS_TYPES
PARAMS_TYPES -> T id | PARAMS, T id
CODE -> DECLARATION CODE
        |ASIGNATION CODE
        |FUNCTION_CALL CODE
        |lambda
TYPE -> int | rectangle | circle | line | dot |  text | bool | double 

IF -> if( CONDITION ){ CODE }
WHILE -> while( CONDITION ){ CODE }

CONDITION -> CONDITION LOGIC CONDITION |
ARITHMETIC -> + | - | * | /
COMPARATOR -> < | > | <= | >= | == | !=
LOGIC -> and | or  
CONSTANT -> DIGIT CONSTANT
DIGIT -> 0|1|2|3|4|5|6|7|8|9
TEXT -> LETTER TEXT| DIGIT TEXT | lambda
LETTER -> a|b|c|...|z|A|B|C|...|Z

id: identificador
T: tipo
F: function definition
D: declaration
B: block
S : instruccion simple


















El significado de los no terminales es el siguiente:
P: Programa
D: Declaraci´on simple
F: lista de instrucciones
S: instrucci´on simple
A: sentencia condicional o alternativa
R: llamada a rutina, funci´on o procedimiento
V : Identificadores o variables
L: Lista de declaraciones simples
T : Tipo de los identificadores
C: Instruccion compuesta
B: Sentencia iterativa o bucle


-------------------------------------
P: programa
C: comentario
I: instrucci´on simple
N: sentencia de control
T: texto
L: letra
D: digito
B: bucle
F: condicional
O: comparaci´on
E: expresi´on
M: operador de comparaci´on
H: t´ermino
J: factor
K: constante
V : variable
A: asignaci´on
R: lectura
W: escritura
